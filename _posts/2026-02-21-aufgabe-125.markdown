---
layout: post
title:  "Project Euler+ #125: Palindromic sums"
date:   2026-02-21
categories: project-euler
---

Nach dem Hammer war das eine gute [Aufgabe][problem] zum Verschnaufen. Dachte ich. Die meisten Tests waren auch gnädig und liefen auf Anhieb durch, aber es gab da drei Stück (die Tests 10, 11 und 12), die sich widerspenstig sträubten und mir grinsend immer wieder TLE's kredenzten. 

Auch nachdem ich eine map angelegt hatte, um die getane Arbeit (für Input-Paare von N, d) zu speichern, ging dieser Unfug weiter. Ich hatte ja von Anfang an den starken Verdacht, dass es an der Funktion zur Überprüfung von Palindromen lag, die ich nicht effizient genug hinbekam. Zunächst erstellte ich -- wie auch bisher bei Palindrom-Aufgaben auf Projekt Euler -- einfach einen Vektor der Ziffern und verglich nacheinander die vorderen und hinteren Indices von außen her, bis ich entweder ungleiche Ziffern fand und false zurückgab oder aber unbescholten die Mitte der Zahl erreichte. Das sah in etwa so aus:

{% highlight c++ %}

using vi = vector<int>;

// digits will be stored in reverse order, no difference for palindromes
vi digits(int n){ 
    vi digs;
    while(n != 0) {
        digs.push_back(n % 10);
        n /= 10;
    }
    return digs;
}

bool is_pal(int n){
    vi v = digits(n);
    int sz = v.size();
    for(int i = 0; i < sz/2; ++i){
        if (v[i] != v[(sz-1)-i]) return false;
    }
    return true;
}

{% endhighlight %}

Ich überlegte schon, alle Palindrome unter einer Milliarde zu erzeugen und immer diese Menge durchsuchen zu lassen. Es dürfte ja "nur" etwa 110'000 Stück geben (man verdoppelt entweder die ersten 9999 Zahlen komplett, macht also z.B. aus 6'438 eine 64'388'346, damit erhält man alle Palindrome mit einer geraden Anzahl von Ziffern oder aber lässt die mittlere Zahl stehen und verdoppelt nur den Rest, was für die ersten 99'999 Zahlen unter 1 Milliarde bleibt, z.B. wird dabei aus 37'295 eine 372'959'273 und damit erzeugt man alle Palindrome mit einer ungeraden Anzahl von Ziffern). Sortiert man einen Vektor dieser Zahlen, kann man binary_search() anwenden und das wäre auch eine mögliche Methode, um is_pal() zu schreiben, wer weiß, aber so weit kam es am Ende gar nicht.

Denn vorher wollte ich noch probieren, ob es reicht, wenn man das Erzeugen von Vektoren (also das Anfordern von Speicherplatz auf dem Heap) gänzlich vermeidet. Das ewige Zuweisen von Adressen und die vielen .push_back() sind zu langsam. Also habe ich einfach die Zahl nach und nach mit einfachen integer-Anweisungen "umgedreht" und dann die ursprüngliche Zahl damit verglichen. Das sieht dann so aus:

{% highlight c++ %}

bool is_pal(int n) {
    if (n % 10 == 0) return false; // last digit zero -> no pal of mine
    int rev = n % 10;
    int left = n / 10;
    while (left > 0) {
        rev *= 10;
        rev += left % 10;
        left /= 10;
    }
    return rev == n;
}

{% endhighlight %}

Und tatsächlich: Mit dieser Version besteht man auch die letzten drei Tests. Puh, da bin ich der unangenehmen Aufgabe der Palindrom-Erzeugung gerade nochmal von der Schippe gesprungen. 

Der Rest des Programms (hier wieder mit Auslassungen wiedergegeben) war eigentlich nicht besonders spektakulär:

{% highlight c++ %}

using ull = unsigned long long;

//---------------------------------- GLOBAL variables -------------------------------------------

int T, N, d;
map<pair<int, int>, ull> calculated; // save our work

//---------------------------------- Helper functions -------------------------------------------


set<int> get_pals(ull lim, int diff) {
    set<int> found; // use a set, since some palindromes are reached multiple times
    for (ull i = 1; ...) { // stop if i*i + i*i is bigger than lim
        ull b = i + diff;
        ull sum = i * i + b * b; // start with at least two summands
        while (sum < lim) { // palindromes must be strictly less than limit!
            ...
        }
    }
    return found;
}

//---------------------------------- MAIN function ----------------------------------------------

int main() {
    cin >> T;
    while (T--) {
        cin >> N >> d;

        pair<int, int> key = {N, d};

        auto it = calculated.find(key);
        if (it != calculated.end()) { // stored?
            cout << (*it).second << endl;
            continue;
        }

        auto found = get_pals((ull)N, d);

        ull res = 0; // may be big
        for (const auto& pal : found) res += pal;
        cout << res << endl;

        calculated[key] = res; // store
    }
    return 0;
}

{% endhighlight %}

Kleiner Nachtrag: Ich habe dann die Version mit der Erzeugung der Palindrome doch noch ausprobiert. War auch einigermaßen erfolgreich (d.h. die Methode ergibt die richtigen Lösungen), aber leider war binary_search() auf einem Vektor mit 109'998 Einträgen dann doch zu langsam (der Logarithmus ist etwa 13) und diesmal bekommen nicht nur die Tests 10 bis 12, sondern zusätzlich auch noch Test 14 ein TLE. Es ist also noch schlechter, als die Ziffer-Vektor-Methode. Hier ein paar Ausschnitte (der Rest des Codes kann belassen werden, in main() muss vor dem Input-Lesen nur fill_palindromes() aufgerufen werden und der Vektor dann noch mit sort() geordnet werden).

{% highlight c++ %}

using pii = pair<int, int>;

vector<int> palindromes = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99};

//---------------------------------- Helper functions -------------------------------------------

pii get_rev_and_len(int n) {
    int rev = n % 10;
    int left = n / 10;
    int len = 1;
    while (left > 0) {
        rev *= 10;
        rev += left % 10;
        left /= 10;
        len++;
    }
    return {rev, len};
}

void fill_palindromes() {
    for (int i = 10; i < 10000; i++) { // pals with even num of digs
        auto [rev, len] = get_rev_and_len(i);
        int pal = i;
        while (len--) pal *= 10;
        pal += rev;
        palindromes.push_back(pal);
    }
    for (int i = 10; i < 100000; i++) { // pals with odd num of digs
        auto [rev, len] = get_rev_and_len(i / 10);
        int pal = i;
        while (len--) pal *= 10;
        pal += rev;
        palindromes.push_back(pal);
    }
}

bool is_pal(int n) { // just do binary search on the sorted vector
    return binary_search(palindromes.begin(), palindromes.end(), n);
}

{% endhighlight %}

Die nächste Aufgabe wird wohl wieder schwerer, an die #126 kann ich mich vom originalen Projekt Euler erinnern, das war die mit den vielen Blöcken und Schichten, da hab ich lange dran gesessen damals. 

[problem]: https://www.hackerrank.com/contests/projecteuler/challenges/euler125/problem
[forum]: https://projecteuler.net/thread=125
[bigint-class]: https://github.com/theartist007/Big-Integer-Class/blob/master/bigint.cpp